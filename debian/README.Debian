Shared libraries
================

For now, the shared libraries of Rust are private.
The rational is the following:
 * Upstream prefers static linking for now
   - https://github.com/rust-lang/rust/issues/10209
 * rust is still under heavy development. As far as we know, there is
   no commitement from upstream to provide a stable ABI for now.
   Until we know more, we cannot take the chance to have Rust-built packages
   failing at each release of the compiler.
 * Static builds are working out of the box just fine
 * However, LD_LIBRARY_PATH has to be updated when -C prefer-dynamic is used

 -- Sylvestre Ledru <sylvestre@debian.org>, Fri, 13 Feb 2015 15:08:43 +0100


Building from source
====================

The Debian rustc package will use the system rustc to bootstrap itself from.
The system rustc has to be either the previous or the same version as the rustc
being built; the build will fail if this is not the case.

    apt-get source --compile rustc

Alternatively, you may give the "pkg.rustc.dlstage0" DEB_BUILD_PROFILE to
instead use the process defined by Rust upstream. This downloads the "official"
stage0 compiler for the version being built from rust-lang.org. At the time of
writing "official" means "the previous stable version".

    apt-get source --compile --build-profiles=pkg.rustc.dlstage0 rustc

If neither of these options are acceptable to you, (e.g. because your build
process cannot access the network), see the below sections on "Bootstrapping"
for more options.


Cross-compiling
===============

Rust uses LLVM, so cross-compiling works a bit differently from the GNU
toolchain. The most important difference is that there are no "cross"
compilers, every compiler is already a cross compiler. All you need to do is
install the standard libraries for each target architecture you want to compile
to. For rustc, this is libstd-rust-dev, so your debian/control would look
something like this:

    Build-Depends:
     [..]
     rustc           (>= $version),
     libstd-rust-dev (>= $version),
     [..]

You need both, this is important. When Debian build toolchains satisfy the
build-depends of a cross-build, (1) a "rustc" Build-Depends implies rustc for
the native architecture, because it's marked as "Multi-Arch: foreign", and this
will implicitly pull in libstd-rust-dev also for the native architecture; and
(2) a "libstd-rust-dev" Build-Depends implies libstd-rust-dev for the foreign
architecture, because it's marked as "Multi-Arch: same".

You'll probably also want to add

    include /usr/share/rustc/architecture.mk

to your debian/rules.

See the cargo package for an example.

Terminology
-----------

The rust ecosystem generally uses the term "host" for the native architecture
running the compiler, equivalent to DEB_BUILD_RUST_TYPE or "build" in GNU
terminology, and "target" for the foreign architecture that the build products
run on, equivalent to DEB_HOST_RUST_TYPE or "host" in GNU terminology. For
example, rustc --version --verbose will output something like:

    rustc 1.16.0
    [..]
    host: x86_64-unknown-linux-gnu

And both rustc and cargo have --target flags:

    $ rustc --help | grep '\-\-target'
        --target TARGET     Target triple for which the code is compiled
    $ cargo build --help | grep '\-\-target'
        --target TRIPLE              Build for the target triple

One major exception to this naming scheme is in CERTAIN PARTS OF the build
scripts of cargo and rustc themselves, such as the `./configure` scripts and
SOME PARTS of the `config.toml` files. Here, "build", "host" and "target" mean
the same things they do in GNU toolchain terminology. However, IN OTHER PARTS
OF the build scripts of cargo and rustc, as well as cargo and rustc's own
output and logging messages, the term "host" and "target" mean as they do in
the previous paragraph. Yes, it's a total mind fuck. :( Table for clarity:

======================================= =============== ========================
GNU term / Debian envvar                Rust ecosystem, Some parts of the rustc
                                        rustc and cargo and cargo build scripts
======================================= =============== ========================
build   DEB_BUILD_{ARCH,RUST_TYPE}      host            build
  the machine running the build
--------------------------------------- --------------- ------------------------
host    DEB_HOST_{ARCH,RUST_TYPE}       target          host(s)
  the machine the build products run on
--------------------------------------- --------------- ------------------------
only relevant when building a compiler
target  DEB_TARGET_{ARCH,RUST_TYPE}     N/A             target(s)
  the one architecture that the built                     extra architectures
  cross-compiler itself builds for                        to build "std" for
--------------------------------------- --------------- ------------------------


Porting to new architectures (on the same distro)
=================================================

As mentioned above, to cross-compile rust packages you need to install the rust
standard library for every target architecture. However, this is not needed
when cross-compiling rustc itself; its buildsystem will build them for you.

By nature, cross-compiles do not run tests. These are important for rustc and
many tests often fail on newly-supported architectures even if builds and
cross-builds work fine. You should find some appropriate way to test your
cross-built packages rather than blindly shipping them to users.

For example, Debian experimental is an appropriate place to upload them, so
that they can be installed and tested on Debian porter boxes, before being
uploaded to unstable and distributed to users.

Using sbuild, in a schroot
--------------------------

0. Set up an schroot for your native architecture, for sbuild:
   https://wiki.debian.org/sbuild

1. Build it:

    sudo apt-get source --download-only rustc
    sbuild --host=$new_arch rustc_*.dsc

Directly on your own system
---------------------------

0. Install the build-dependencies of rustc (including cargo and itself):

    sudo dpkg --add-architecture $new_arch
    sudo apt-get --no-install-recommends build-dep --host-architecture=$new_arch rustc

1. Build it:

    apt-get source --compile --host-architecture=$new_arch rustc

    sudo apt-get build-dep --build-profile=nodoc rustc
    dpkg-buildpackage -t $new_arch

Directly from upstream binaries
-------------------------------

Use the same instructions as given in "Bootstrapping" below, setting the
relevant architectures.


Bootstrapping
=============

To bootstrap rustc a distro that does not have it or cargo on any architecture,
i.e. where cross-compiling is not an option, you can run `debian/rules
source_orig-dl`. This creates a .dsc that does not Build-Depend on rustc or
cargo. Instead, it includes an extra orig-dl source tarball that contains the
official stage0 compiler, pre-downloaded from rust-lang.org so that your build
daemons don't need to access the network during the build.

    debian/rules source_orig-dl
    sbuild ../rustc_*.dsc && dput ../rustc_*.dsc

To only bootstrap specific architectures, run this instead:

    upstream_bootstrap_arch="arm64 armel armhf" debian/rules source_orig-dl

This way, other architectures will be omitted from the orig-dl tarball. You
might want to do this e.g. if these other architectures are already present in
your distro, but the $upstream_bootstrap_arch ones are not yet present.

Notes
-----

The approach bundles the upstream bootstrapping binaries inside the Debian
source package. This is a nasty hack that stretches the definition of "source
package", but has a few advantages explained below.

The traditional Debian way of bootstrapping compilers - and other distros have
similar approaches - is some variant of the following:

1. A developer locally installs some upstream bootstrapping binaries.
2. They locally build a Debian package, using these binaries as undeclared
   build dependencies.
3. They upload these binary packages to Debian, which can be used as declared
   Build-Depends in the future, including by the same package.

The problem with this is, Debian does not have any policy nor infrastructure
that can try to reproduce what this developer supposedly did.

Using bootstrapping binary blobs *at some point of the process* is unavoidable.
Rather than pretending we didn't do this, it is better to record *which blobs*
we used, so it can be audited later. If we bundle non-Debian build-dependencies
inside the source package, then we can do a *source-only upload*, and the
building of the binary packages can be done by the normal build infrastructure.

If the build process is reproducible [1] then we can be sure that *you* (as the
developer that prepared the source-only upload) didn't backdoor the binaries,
nor did the build daemons even if they were compromised during the build.

The bootstrapping binaries may still have been backdoored, but this is true in
both scenarios. So our arrangement is still a strict improvement in security,
because it reduces the set of "things that may have been backdoored". Also,
more people use the upstream binaries than the "magical original Debian
package", so that any backdoors have a greater chance of being detected.

In the long run, this process is laying the foundations for doing Diverse
Double-Compilation [2], where we use *many independent* bootstrapping binaries
to reproduce bit-for-bit identical output compilers, giving confidence that
nothing was backdoored along the way.

[1] The build process for rustc is currently *not* reproducible but we're
    working towards it. https://github.com/rust-lang/rust/issues/34902
[2] http://www.dwheeler.com/trusting-trust/

Description: [01/03] Support building against a local-rust of the current version
 mk: Add --enable-local-rebuild to bootstrap from the current release
 .
 In Linux distributions, it is often necessary to rebuild packages for
 cases like applying new patches or linking against new system libraries.
 In this scenario, the rustc in the distro build environment may already
 match the current release that we're trying to rebuild.  Thus we don't
 want to use the prior release's bootstrap key, nor `--cfg stage0` for
 the prior unstable features.
 .
 The new `configure --enable-local-rebuild` option specifies that we are
 rebuilding from the current release.  The current bootstrap key is used
 for the local rustc, and current stage1 features are also assumed.
Author: Josh Stone <cuviper@gmail.com>
Bug: https://github.com/rust-lang/rust/pull/33787
Applied-Upstream: commit:3406c55144339dea81839adc9addd931e068084a
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/configure
+++ b/configure
@@ -599,6 +599,7 @@
 opt fast-make 0 "use .gitmodules as timestamp for submodule deps"
 opt ccache 0 "invoke gcc/clang via ccache to reuse object files between builds"
 opt local-rust 0 "use an installed rustc rather than downloading a snapshot"
+opt local-rebuild 0 "use an installed rustc matching the current version, for rebuilds"
 opt llvm-static-stdcpp 0 "statically link to libstdc++ for LLVM"
 opt rpath 1 "build rpaths into rustc itself"
 opt stage0-landing-pads 1 "enable landing pads during bootstrap with stage0"
@@ -847,6 +848,16 @@
     BIN_SUF=.exe
 fi
 
+# --enable-local-rebuild implies --enable-local-rust too
+if [ -n "$CFG_ENABLE_LOCAL_REBUILD" ]
+then
+    if [ -z "$CFG_ENABLE_LOCAL_RUST" ]
+    then
+        CFG_ENABLE_LOCAL_RUST=1
+        putvar CFG_ENABLE_LOCAL_RUST
+    fi
+fi
+
 if [ -n "$CFG_ENABLE_LOCAL_RUST" ]
 then
     system_rustc=$(which rustc)
--- a/mk/main.mk
+++ b/mk/main.mk
@@ -34,7 +34,14 @@
 # intentionally not "secure" by any definition, this is largely just a deterrent
 # from users enabling unstable features on the stable compiler.
 CFG_BOOTSTRAP_KEY=$(CFG_FILENAME_EXTRA)
+
+# The stage0 compiler needs to use the previous key recorded in src/stage0.txt,
+# except for local-rebuild when it just uses the same current key.
+ifdef CFG_ENABLE_LOCAL_REBUILD
+CFG_BOOTSTRAP_KEY_STAGE0=$(CFG_BOOTSTRAP_KEY)
+else
 CFG_BOOTSTRAP_KEY_STAGE0=$(shell grep 'rustc_key' $(S)src/stage0.txt | sed 's/rustc_key: '//)
+endif
 
 ifeq ($(CFG_RELEASE_CHANNEL),stable)
 # This is the normal semver version string, e.g. "0.12.0", "0.12.0-nightly"
@@ -526,6 +533,11 @@
 CFGFLAG$(1)_T_$(2)_H_$(3) = stage1
 
 RPATH_VAR$(1)_T_$(2)_H_$(3) := $$(TARGET_RPATH_VAR1_T_$(2)_H_$$(CFG_BUILD))
+else
+ifdef CFG_ENABLE_LOCAL_REBUILD
+# Assume the local-rebuild rustc already has stage1 features too.
+CFGFLAG$(1)_T_$(2)_H_$(3) = stage1
+endif
 endif
 endif
 
